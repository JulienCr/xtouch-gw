# MEMORY

But: noter les erreurs, impasses et choix importants pour ne pas les répéter.

## Garde-fous
- Utiliser exclusivement pnpm/pnpx (pas npm/npx).
- Version Node ciblée: 24.1+ (engines configuré). 
- Tenir `TASKS.md` à jour après chaque lot de travail.

## Entrées
- 2025-08-21 — Schémas de flux (Mermaid)
  - Ajout de `docs/flows.md` couvrant: démarrage app, changement de page, OBS (actions/indicateurs), QLC+ (passthrough et controls.midi).
  - Source: code actuel (`src/app.ts`, `src/app/bootstrap.ts`, `src/app/navigation.ts`, `src/router.ts`, `src/router/page.ts`, `src/drivers/*`, `src/services/controlMidiSender.ts`).
  - Leçon: documenter les responsabilités entre Router/Bootstrap/Drivers et séparer indicateurs driver‑driven des LEDs de navigation.
  - Règles Mermaid (compat):
    - Éviter l’Unicode dans les labels: remplacer →, —, ’, « X‑Touch » par ASCII (->, -, ', X-Touch).
    - Pas de parenthèses dans les titres de subgraph (utiliser _ ou mots simples sans ()).
    - Préférer labels courts ASCII; ok pour `-- yes/no -->` et `-. label .->`.
    - Éviter les labels d’arêtes exotiques; si besoin, rester `-- text -->`.
- 2025-08-21 — Intégration Docs MCP locale
  - Décision: générer la doc API (TypeDoc Markdown/HTML) puis indexer `docs/api` via `file://` dans une librairie `<package-name>-api` versionnée.
  - Implémentation: scripts pnpm (`docs:build`, `docs:mcp`, `docs:mcp:web`, `docs:mcp:scrape`) et helper `scripts/docs-mcp-scrape.mjs` (construction file:// robuste via `pathToFileURL`).
  - Leçon: privilégier Markdown (`docs/api`) pour un parsing plus propre côté serveur; garder HTML à disposition.
- 2025-08-20 — Fonctionnalité controls.midi et résolution des bugs de coexistence
  - Décision: introduire `controls.*.midi { type, channel, cc|note }` pour un routage global générique (toutes apps) sans dupliquer de logique dans les drivers.
  - Implémentation: service `src/services/controlMidiSender.ts` (cache de ports, conversion 14b→7b pour CC), `Router.handleControl()` priorise `midi` sur `action`, `inputMapper` émet valeur14 pour faders PB.
  - Leçon: factoriser la logique d'envoi MIDI hors drivers spécifiques, conserver OBS/Voicemeeter/QLC pur API côté drivers.
  - Besoin: recaler rapidement surface/états/drivers après dérive (déconnexions OBS, reboot, etc.).
  - Solution: nouveau hook optionnel `Driver.sync()` appelé via `Router.syncDrivers()`, et commande CLI `sync` enchaînant reset X‑Touch → reload snapshot → sync drivers → refresh page/LCD.
  - Leçon: centraliser la resynchro côté Router/CLI, laisser chaque driver gérer sa lecture d'état.
  - **Bugs rencontrés et solutions:**
    - **Offset pb_to_cc (+1)**: Le calcul `base_cc + channel_source` était incorrect. Fix: `base_cc + (channel_source - 1)` pour que fader1→CC81, fader2→CC82, etc.
    - **Passthrough cassé après controls.midi**: L'inputMapper appelait `handleControl` même sur les pages sans mapping controls. Fix: filtrer les appels PB→handleControl uniquement si le control_id existe dans la page active.
    - **Passthrough et controls.midi en conflit**: Double écoute des ports MIDI causant des conflits. Fix: prioriser les passthroughs, fermer les ports controlMidiSender quand un passthrough est actif.
    - **Feedback manquant pour controls.midi**: Pas de mise à jour de l'état après envoi. Fix: ouverture de ports d'entrée dédiés + optimistic update immédiat du state.
    - **Désynchronisation entre pages**: Fader déplacé sur page passthrough non reflété sur page controls.midi. Fix: optimistic update dans midiBridge + controlMidiSender pour maintenir le state à jour.
  - **Leçons apprises:**
    - **Gestion des ports MIDI**: Un seul service doit "posséder" les ports IN/OUT pour une app donnée. Prioriser les passthroughs sur les controls.midi.
    - **Optimistic updates**: Mettre à jour le state immédiatement après envoi MIDI pour éviter les désynchronisations lors des changements de page.
    - **Filtrage des événements**: Ne traiter les événements controls.midi que quand ils sont explicitement mappés sur la page active.
    - **Mutualisation du code**: Factoriser la logique de setpoint des faders dans un utilitaire partagé pour éviter la duplication.
    - **Coexistence des systèmes**: Les passthroughs et controls.midi peuvent coexister mais nécessitent une gestion stricte des priorités et des ports.
    - **Feedback manquant sur pages avec passthroughs**: QLC feedback (CC 78) n'était pas transformé vers X‑Touch sur les pages avec seulement un passthrough Voicemeeter. Fix: `getAppsForPage()` doit toujours inclure les apps référencées par `controls.*` en plus des passthroughs.
    - **Ports MIDI en double sur Windows**: ControlMidiSender tentait d'ouvrir un port IN pour QLC même si un passthrough existait ailleurs, causant "port already in use" et "ouverture IN échouée". Fix: vérifier les passthroughs sur toutes les pages, pas seulement la page active.
    - **Hardcoding des noms de contrôles**: Logique spécifique à `fader_master` et regex `fader(\d+)` rendait le code non extensible. Fix: centraliser la lecture de `docs/xtouch-matching.csv` dans un module `matching.ts` générique, avec des lookups `getPbChannelForControlId()` et `getInputLookups()`.
    - **Duplication de la logique CSV**: Parsing du CSV dupliqué entre `inputMapper` et `router/page.ts`. Fix: factoriser dans `matching.ts` avec cache et API unifiée, éviter la duplication des chemins par défaut.
  - **Leçons de design:**
    - **Généricité des mappings**: Ne jamais hardcoder des noms de contrôles ou d'apps dans la logique. Utiliser des sources de données externes (CSV, config) pour rester extensible.
    - **Centralisation des parsers**: Un seul endroit doit connaître le format et l'emplacement des fichiers de mapping. Exposer des APIs génériques plutôt que de dupliquer la logique.
    - **Union des sources d'apps**: Une page peut avoir des apps via passthroughs ET via controls, les deux doivent être considérés pour le feedback et le routing.
  - Décision (architecture): chevauchement observé entre `drivers/midiBridge.ts` et `services/controlMidiSender.ts` (gestion des ports IN/OUT, optimistic update/shadow, setpoints faders). Facteur commun à extraire: un client partagé `MidiAppClient` (ouverte/fermeture ports, envoi Note/CC/PB, conversion PB→CC 14b→7b, onFeedback → `Router.onMidiFromApp`). `MidiBridgeDriver` reste l'orchestrateur de passthrough page-scopé; `controls.*.midi` utilise ce client.
  - **Prochaines étapes de déduplication** (après extraction `MidiAppClient`):
    - Exposer `ensureFeedback(app: string)` public dans `MidiAppClient` et l'appeler depuis `controlMidiSender` (supprimer `(client as any)["ensureFeedbackOpen"]`).
    - Remplacer les appels directs au Router par `markAppOutgoingAndForward()`: `src/drivers/voicemeeter.ts` (shadow-only → helper partagé, ajouter optimistic forward pour parité avec `midiBridge`).
    - Diviser `src/midi/appClient.ts` (>150 lignes) en modules plus petits: `midi/appClient/core.ts` (send/convert/ports), `midi/appClient/feedback.ts` (wiring IN), `midi/appClient/index.ts` (API publique).
    - Tests unitaires ciblés sur `MidiAppClient`: conversion PB 14b→7b, résolution canal CC→PB via `resolvePbToCcMappingForApp`, updates optimistes, gating listener feedback (passthrough présent).
    - JSDoc sur `midi/appClient/*` et points de contact service/driver mis à jour.
    - Optionnel: factoriser le helper "open by fragment" retournant {device, index} pour DRY les petits patterns open-then-close dans `voicemeeter.ts` sans forcer sur `MidiAppClient` (pas app-scopé).
- 2025-08-20 — Ajout d'un cycle de resynchronisation global (CLI `sync`)
- 2025-08-20 — Mapping MIDI direct par contrôle
  - Décision: introduire `controls.*.midi { type, channel, cc|note }` pour un routage global générique (toutes apps) sans dupliquer de logique dans les drivers.
  - Implémentation: service `src/services/controlMidiSender.ts` (cache de ports, conversion 14b→7b pour CC), `Router.handleControl()` priorise `midi` sur `action`, `inputMapper` émet valeur14 pour faders PB.
  - Leçon: factoriser la logique d’envoi MIDI hors drivers spécifiques, conserver OBS/Voicemeeter/QLC pur API côté drivers.
  - Besoin: recaler rapidement surface/états/drivers après dérive (déconnexions OBS, reboot, etc.).
  - Solution: nouveau hook optionnel `Driver.sync()` appelé via `Router.syncDrivers()`, et commande CLI `sync` enchaînant reset X‑Touch → reload snapshot → sync drivers → refresh page/LCD.
  - Leçon: centraliser la resynchro côté Router/CLI, laisser chaque driver gérer sa lecture d’état.
- 2025-08-20 — Aide CLI illisible via logger
  - Symptôme: liste de commandes sur une seule ligne via logger, dépendante du niveau de logs.
  - Solution: refonte UX-first de l'aide: `help.yaml` v2 (meta/context/categories), rendu cheatsheet coloré avec catégories, usages et exemples; support `help <cmd|cat|all|examples|json>`, suggestions Levenshtein, alias `:` (ex: `midi:open`) + compat; ajout `completion <zsh|bash|powershell>`; header contextuel (config/page/ports/logs). `clear` conserve un effacement stdout.
  - Leçon: éviter le logger pour les aides interactives; privilégier stdout et une source éditable (YAML).
 - 2025-08-20 — Complétion REPL manquante
  - Symptôme: pas de Tab-complete dans la REPL, malgré un script `completion` rudimentaire côté shell.
  - Solution: ajout d’un `readline.completer` avec suggestions contextuelles (commandes de base, `page` → pages/index, `midi-open` → noms/index de ports, `state`/`show`/`completion` → sous-commandes, `fader`/`lcd` → bornes).
  - Leçon: pour une REPL, préférer la complétion intégrée (stateful) plutôt que des scripts shell statiques.
- 2025-08-20 — LEDs navigation écrasées par indicateurs génériques
  - Symptôme: à l'arrivée sur une page, Prev/Next et F1..F8 s'allument puis s'éteignent immédiatement.
  - Cause: `attachIndicators()` ré-émettait des NoteOn à 0 pour tous les contrôles mappés par CSV, y compris ceux sans indicateur actif, écrasant les LEDs gérées par `fkeys`.
  - Fix: dans `src/xtouch/indicators.ts`, ne toucher qu'aux LEDs présentes dans `litByControlId` (celles avec un indicateur explicite). Les LEDs navigation restent gérées par `updateFKeyLedsForActivePage`/`updatePrevNextLeds`.
  - Leçon: isoler les responsabilités LED — navigation vs indicateurs d'app — et éviter les write-all par défaut.
 - 2025-08-20 — InputMapper (MCU) ne routait pas les faders 2..8
   - Symptôme: seul `fader1` fonctionnait; logs « Aucun mapping pour 'faderX_touch' ».
   - Cause: filtre global par `paging.channel` appliqué aussi aux Pitch Bend (faders MCU), rejetant les PB sur ch2..8.
   - Fix: parser `pb=chN` depuis `docs/xtouch-matching.csv` et construire `pbChannelToControl`; n'appliquer le filtre de canal qu'aux Note/CC; accepter PB sur tous canaux et router selon la table.
   - Leçon: en MCU, le canal MIDI d'un fader est sémantique (strip). Le filtrage de canal doit être spécifique au type de message.
 - 2025-08-20 — Setpoint moteur incorrect sur faders 2..8 (controls.midi)
  - Symptôme: après mouvement d'un fader 2..8, le moteur se recalait mal ou revenait à une position incorrecte.
  - Cause: `scheduleFaderSetpoint()` était appelé avec le canal CC cible (souvent CH1 pour QLC) au lieu du canal du fader source (CH2..8).
  - Fix: dans `controlMidiSender.ts`, déduire le canal fader depuis la page active via `resolvePbToCcMappingForApp()` et le mapping CC→PB, puis programmer le setpoint sur ce canal.
  - Leçon: en MCU, le canal MIDI d'un fader (source) et le canal CC cible (destination) sont distincts. Le setpoint moteur doit toujours être sur le canal source.
 - 2025-08-20 — Defaults globaux pages
   - Décision: introduire `pages_global` dans `config.yaml` pour définir des contrôles/LCD/passthroughs communs.
   - Implémentation: fusion au runtime dans `Router.mergeGlobalIntoPage()` sans muter la config; override par page.
 - 2025-08-16 — Infra tests
   - Décision: utiliser Vitest avec couverture v8 et convention `_tests` (tests co-localisés dans des sous-dossiers `_tests` à côté du code, ex: `src/midi/_tests/utils.test.ts`).
   - Scripts: `pnpm test`, `pnpm test:watch`, `pnpm lint`, `pnpm format`.
 - 2025-08-16 — Reload state au démarrage
   - Décision: hydrater le `StateStore` depuis `.state/snapshot.json` si présent, sans notifier les abonnés.
   - Implémentation: méthode `hydrateFromSnapshot()` dans `StateStore`, chargée au bootstrap de la persistance. Les entrées sont marquées `stale: true` pour signaler qu’elles peuvent être obsolètes et déclencher un refresh de page sans boucles.
- 2025-08-08 — Init
  - Décision: TypeScript + tsx (dev) + tsc (build).
  - Décision: `chalk@4` pour compat CJS simple; évite ESM-only de chalk@5 au démarrage.
  - Décision: `config.yaml` racine avec `config.example.yaml` d’illustration.
- 2025-08-08 — Sniffer MIDI
  - Problème: `pnpm add midi` échoue (node-gyp, MSBuild) sous Windows + Node 24.1.
  - Solution: `@julusian/midi` fonctionne immédiatement (précompilé/N-API). Sniffer natif intégré (CLI: midi-ports, midi-open, midi-close).
  - Fallback: sniffer Web MIDI dispo via `pnpm sniff:web` → `http://localhost:8123/`.
 - 2025-08-09 — loopMIDI en sécurité (boucle)
   - Symptôme: plus aucune sortie MIDI, ports “gelés”.
   - Cause: boucle de routage (X‑Touch ↔ bridge ↔ retour vers le même flux) détectée par loopMIDI → mise en sécurité.
   - Actions: couper VM Sync si besoin, désactiver un des ponts, vérifier filtres/ports (pas de renvoi du feedback vers l’entrée source), redémarrer loopMIDI. 
 - 2025-08-16 — Flag vm_sync retiré
   - Décision: retirer `features.vm_sync` (non utilisé runtime). Nettoyage types, UI editor, README, YAML, tests.
 - 2025-08-09 — QLC+ ne gère pas Pitch Bend
   - Décision: ajout d’un transformer `pb_to_note` côté `MidiBridgeDriver` pour convertir Pitch Bend → Note On (même canal) avec vélocité mappée (0..127).
   - Usage: dans `config.yaml`, sous `passthroughs[].transform.pb_to_note.note` définir la note (ex: 0). Évite d’envoyer des PB à QLC+.
  - 2025-08-10 — Conversion PB → CC pour QLC+
    - Décision: ajout de `pb_to_cc` pour convertir Pitch Bend → Control Change (valeur 0..127) avec canal cible configurable et CC calculé par canal source (`base_cc` ou `cc_by_channel`).
    - Exemple: ch4 PB → ch1 CC 49 val[0..127]; ch1→CC46, ch2→CC47.
  - 2025-08-10 — Feedback inverse auto
    - Décision: toute transformation sortante (PB→Note, PB→CC) a son miroir automatique pour le feedback entrant (`Note/CC` → `PitchBend` vers X‑Touch) sans configuration supplémentaire.
  - 2025-08-10 — Refactor utilitaires
    - Décision: extraire le rendu LCD et les fonctions MIDI communes pour réduire la duplication et faciliter les tests.
    - Fichiers: `src/ui/lcd.ts`, `src/midi/utils.ts`, `src/midi/filter.ts`, `src/midi/transform.ts`. Mise à jour de `app.ts` et `drivers/midiBridge.ts` pour utiliser ces utilitaires.
  - 2025-08-10 — Oubli de rebuild → ancien comportement
    - Symptôme: après modification du code, le LCD affiche encore le nom de page (ancien fallback) et ignore la nouvelle logique.
    - Cause: process non redémarré / pas de rebuild → ancienne version en cours.
    - Rappel: après des changements de logique, redémarrer le process (`pnpm dev`) ou lancer un type-check (`pnpm run check:types`) et relancer. Le hot reload YAML ne recharge pas le code.
  - 2025-08-10 — App web séparée pour l’édition de config
    - Décision: isoler un éditeur Next.js dans `web/config-editor` pour éviter toute interaction avec la GW.
    - Implémentation: API GET/PUT `/api/config` qui lit/écrit le `config.yaml` racine; UI YAML avec validation et preview JSON.
  - 2025-08-10 — State virtuel MIDI & multipage
    - Décision: adopter une source de vérité MIDI-only par app (Note/CC/PB/SysEx) via `StateStore` avec anti-boucle (50ms) et `lastSentToXTouch`.
    - Implémentation: capture des feedbacks depuis `VoicemeeterDriver` et `MidiBridgeDriver` vers le `Router.onMidiFromApp()`; mapping automatique de l’app (`qlc`/`voicemeeter`/`obs`) selon les ports bridge. Refresh de page ordonné (Notes→CC→LCD→Faders). Fix: `nextPage()` appelait pas `refreshPage()` → ajouté. Reset par défaut: canal 1, notes 0..31 uniquement (LED).
    - À améliorer: filtrage par mapping de page → `MidiAddr` et persistance `.state/xtouch-gw.json`.
  - 2025-08-10 — Pages 3/4 ne se refreshent pas
    - Symptôme: en naviguant vers P3/P4, pas de mise à jour des faders/LED.
    - Cause: mauvaise hypothèse sur le canal cible; QLC attend les CC sur le canal 1.
    - Fix: conserver `target_channel: 1` et clarifier `base_cc` en hex (P3: 0x45, P4: 0x50). Le feedback CC (CH1) est correctement inversé vers PB pour le refresh de page.
- 2025-08-15 — Refactor State MIDI-only + Reset→Replay (nouvelle spec)
  - Changements majeurs: `MidiAddr` {portId,status,channel,data1}, `MidiStateEntry` {known,origin,stale?}; suppression des defaults dans le state; transforms “in/out” centralisées dans le Router; anti-boucle via `XTouchShadow` (valeur+ts) et `AppShadow`.
  - Persistance légère: `.state/journal.log` (append-only) + `.state/snapshot.json` (RAM périodique) pour debug.
  - Reset→Replay: Notes OFF/CC 0 pour unknown; PB=0 (spéc révisée) si aucun PB/CC mappé connu; SysEx HOLD.
  - Mapping CC→PB: support `base_cc` (1..9) + `cc_by_channel`; lookup CC par canal puis global.
  - Correction appliquée: construction d’un plan PB par fader (priorités PB connu > CC→PB > 0) et émission en une seule passe. Évite les PB=0 après des PB connus au retour sur Page 1 (Voicemeeter+QLC). Les mutes Notes sont rejouées via plan Notes.
  - Observation: latence importante (~1 s) sur le feedback (LED/mutes) et recalage des faders après mouvement. Hypothèses: latence cumulée des bridges, fenêtre anti‑echo trop courte, echoPitchBend en conflit, listeners doublons. Actions listées dans `TASKS.md`.
 - 2025-08-15 — Documentation JSDoc/TypeDoc
   - Décision: générer la doc API avec TypeDoc + plugin Markdown, sortie `docs/api` dans le repo pour lecture hors-ligne.
   - Implémentation: `typedoc.json`, scripts `pnpm run docs`, `pnpm run docs:clean`. Warnings supprimés en ajoutant `src/config.ts` aux entry points et en exportant `MessageHandler`; JSDoc complétée sur `config.ts` et `xtouch/driver.ts`.
 - 2025-08-15 — Refactors anti-echo & transforms
   - Nettoyage: suppression des reverse transforms dans `src/midi/transform.ts`; ces miroirs sont gérés par `router/page.ts` (mapping CC→PB lors du refresh/replay).
   - Robustesse: remplacement des littéraux `?? 60` par `getAntiLoopMs(status)` dans `router` pour cohérence des fenêtres anti-echo.
   - Archivage: déplacement de `config copy.yaml` vers `docs/ARCHIVES/` pour éviter les doubles sources de config.
 - 2025-08-16 — Env non chargé assez tôt
   - Symptôme: `LOG_LEVEL` depuis `.env` ignoré; le logger lisait la valeur par défaut `info`.
   - Cause: `dotenv.config()` appelé après import du `logger`, avec un chemin relatif erroné (`../.env`).
   - Fix: utiliser `import "dotenv/config"` au tout début de `src/index.ts` (avant tout import), laisser le chemin par défaut (racine du process), et retirer le `console.trace(process.env)` bruyant.
- 2025-08-16 — Refactor test MIDI
  - Décision: déplacer la logique générique du script `src/test-midi-send.ts` vers des utilitaires réutilisables et testables.
  - Implémentation: nouveaux fichiers `src/test-utils/openRawSender.ts`, `src/test-utils/runners.ts`, `src/test-utils/runMidiTest.ts`. Le script `src/test-midi-send.ts` est réduit et s’appuie sur `xtouch/api`.